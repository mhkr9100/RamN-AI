
import { useState, useEffect, useRef, useCallback } from 'react';
import { GlobalTask } from '../types';
import { dbService, STORES_ENUM } from '../services/db';

export const useTasks = (onProcessTask: (task: GlobalTask) => Promise<string | undefined>) => {
    const [globalTasks, setGlobalTasks] = useState<GlobalTask[]>([]);
    const stateRef = useRef({ globalTasks });

    // Sync ref to prevent stale closures in the scheduler interval
    useEffect(() => {
        stateRef.current = { globalTasks };
    }, [globalTasks]);

    // Initial Load from IndexedDB
    useEffect(() => {
        const load = async () => {
            try {
                const allTasks = await dbService.getAll<GlobalTask>(STORES_ENUM.TASKS);
                setGlobalTasks(allTasks);
            } catch (e) {
                console.error("Task Load Error:", e);
            }
        };
        load();
    }, []);

    const updateTaskStatus = useCallback((taskId: string, status: GlobalTask['status'], output?: string) => {
        setGlobalTasks(prev => {
            const updated = prev.map(t => t.id === taskId ? { ...t, status, ...(output !== undefined ? { output } : {}) } : t);
            const task = updated.find(t => t.id === taskId);
            if (task) dbService.put(STORES_ENUM.TASKS, task);
            return updated;
        });
    }, []);

    const runSilentExecution = useCallback(async (task: GlobalTask) => {
        // Prevent double-processing
        if (task.status === 'processing') return;
        
        updateTaskStatus(task.id, 'processing');
        try {
            const result = await onProcessTask(task);
            if (result !== undefined) {
                updateTaskStatus(task.id, 'done', result);
            } else {
                updateTaskStatus(task.id, 'not-done', 'Error: No output generated by agent.');
            }
        } catch (e) {
            console.error("Directive Execution Fault:", e);
            updateTaskStatus(task.id, 'not-done', `Fault: ${e instanceof Error ? e.message : 'Unknown error'}`);
        }
    }, [onProcessTask, updateTaskStatus]);

    /**
     * PRECISION SCHEDULER RUNNER
     * Polls every 2 seconds. Uses stateRef to ensure it sees the latest tasks.
     */
    useEffect(() => {
        const interval = setInterval(() => {
            const now = Date.now();
            const dueTasks = stateRef.current.globalTasks.filter(t => 
                (t.status === 'scheduled') && 
                t.scheduledTime && 
                t.scheduledTime <= now
            );

            if (dueTasks.length > 0) {
                dueTasks.forEach(task => {
                    runSilentExecution(task);
                });
            }
        }, 2000); 
        return () => clearInterval(interval);
    }, [runSilentExecution]);

    const updateTask = useCallback((taskId: string, data: Partial<GlobalTask>) => {
        setGlobalTasks(prev => {
            const updated = prev.map(t => t.id === taskId ? { ...t, ...data } : t);
            const task = updated.find(t => t.id === taskId);
            if (task) dbService.put(STORES_ENUM.TASKS, task);
            return updated;
        });
    }, []);

    const deleteTask = useCallback((taskId: string) => {
        setGlobalTasks(prev => prev.filter(t => t.id !== taskId));
        dbService.delete(STORES_ENUM.TASKS, taskId);
    }, []);

    const handleAddGlobalTask = useCallback((data: { 
        label: string; 
        scheduledTime?: number; 
        isRecurring?: boolean; 
        recurrenceType?: GlobalTask['recurrenceType'];
        recurrenceValue?: string;
        agentId: string; 
        teamId?: string; 
        status?: GlobalTask['status']; 
        output?: string 
    }) => {
        const now = Date.now();
        const schedTime = data.scheduledTime || now;
        const isImmediate = schedTime <= now + 2000;
        
        const newTask: GlobalTask = {
            id: `gt-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            agentId: data.agentId,
            teamId: data.teamId,
            label: data.label,
            status: data.status || 'scheduled',
            createdAt: Date.now(),
            scheduledTime: schedTime,
            isRecurring: data.isRecurring || false,
            recurrenceType: data.recurrenceType,
            recurrenceValue: data.recurrenceValue,
            output: data.output
        };
        
        setGlobalTasks(prev => {
            const next = [...prev, newTask];
            dbService.put(STORES_ENUM.TASKS, newTask);
            return next;
        });
        
        if (isImmediate && !data.status) {
            runSilentExecution(newTask);
        }
    }, [runSilentExecution]);

    return { globalTasks, updateTaskStatus, updateTask, deleteTask, handleAddGlobalTask };
};
